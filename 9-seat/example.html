<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>扩展示例代码 - The Wayland Protocol 中文版</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="The Wayland Protocol 中文版">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">译者言</a></li><li class="chapter-item expanded "><a href="../1-introduction/index.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1-introduction/high-level-design.html"><strong aria-hidden="true">1.1.</strong> Wayland 上层设计</a></li><li class="chapter-item expanded "><a href="../1-introduction/goals.html"><strong aria-hidden="true">1.2.</strong> 目标和受众</a></li><li class="chapter-item expanded "><a href="../1-introduction/package.html"><strong aria-hidden="true">1.3.</strong> Wayland 软件包</a></li></ol></li><li class="chapter-item expanded "><a href="../2-protocol-design/index.html"><strong aria-hidden="true">2.</strong> 协议设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2-protocol-design/wire-protocol.html"><strong aria-hidden="true">2.1.</strong> 基础 Wire 协议</a></li><li class="chapter-item expanded "><a href="../2-protocol-design/interfaces-reqs-events.html"><strong aria-hidden="true">2.2.</strong> 接口与事件请求</a></li><li class="chapter-item expanded "><a href="../2-protocol-design/high-level.html"><strong aria-hidden="true">2.3.</strong> 上层协议</a></li><li class="chapter-item expanded "><a href="../2-protocol-design/design-patterns.html"><strong aria-hidden="true">2.4.</strong> 协议设计规范</a></li></ol></li><li class="chapter-item expanded "><a href="../3-libwayland/index.html"><strong aria-hidden="true">3.</strong> libwayland</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3-libwayland/util.html"><strong aria-hidden="true">3.1.</strong> wayland-util 原语</a></li><li class="chapter-item expanded "><a href="../3-libwayland/wayland-scanner.html"><strong aria-hidden="true">3.2.</strong> wayland-scanner</a></li><li class="chapter-item expanded "><a href="../3-libwayland/proxies.html"><strong aria-hidden="true">3.3.</strong> 资源与代理</a></li><li class="chapter-item expanded "><a href="../3-libwayland/interfaces.html"><strong aria-hidden="true">3.4.</strong> 接口与监听</a></li></ol></li><li class="chapter-item expanded "><a href="../4-wayland-display/index.html"><strong aria-hidden="true">4.</strong> wayland display</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../4-wayland-display/creation.html"><strong aria-hidden="true">4.1.</strong> display 创建</a></li><li class="chapter-item expanded "><a href="../4-wayland-display/event-loop.html"><strong aria-hidden="true">4.2.</strong> 加入事件循环</a></li></ol></li><li class="chapter-item expanded "><a href="../5-registry/index.html"><strong aria-hidden="true">5.</strong> 全局变量与注册</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../5-registry/binding.html"><strong aria-hidden="true">5.1.</strong> 绑定全局变量</a></li><li class="chapter-item expanded "><a href="../5-registry/server-side.html"><strong aria-hidden="true">5.2.</strong> 注册全局变量</a></li></ol></li><li class="chapter-item expanded "><a href="../6-surfaces/index.html"><strong aria-hidden="true">6.</strong> 缓冲区与表面</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../6-surfaces/compositor.html"><strong aria-hidden="true">6.1.</strong> wl_compositor 使用</a></li><li class="chapter-item expanded "><a href="../6-surfaces/shared-memory.html"><strong aria-hidden="true">6.2.</strong> 共享内存 buffer</a></li><li class="chapter-item expanded "><a href="../6-surfaces/dmabuf.html"><strong aria-hidden="true">6.3.</strong> Linux dmabuf</a></li><li class="chapter-item expanded "><a href="../6-surfaces/roles.html"><strong aria-hidden="true">6.4.</strong> Surface roles</a></li></ol></li><li class="chapter-item expanded "><a href="../7-xdg-shell-basics/index.html"><strong aria-hidden="true">7.</strong> XDG shell 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../7-xdg-shell-basics/xdg-surface.html"><strong aria-hidden="true">7.1.</strong> XDG 表面</a></li><li class="chapter-item expanded "><a href="../7-xdg-shell-basics/xdg-toplevel.html"><strong aria-hidden="true">7.2.</strong> 应用程序窗口</a></li><li class="chapter-item expanded "><a href="../7-xdg-shell-basics/example-code.html"><strong aria-hidden="true">7.3.</strong> 扩展示例代码</a></li></ol></li><li class="chapter-item expanded "><a href="../8-surfaces-in-depth/index.html"><strong aria-hidden="true">8.</strong> 深入理解表面</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../8-surfaces-in-depth/lifecycle.html"><strong aria-hidden="true">8.1.</strong> 表面的生命周期</a></li><li class="chapter-item expanded "><a href="../8-surfaces-in-depth/frame-callbacks.html"><strong aria-hidden="true">8.2.</strong> 帧回调</a></li><li class="chapter-item expanded "><a href="../8-surfaces-in-depth/damaging-surfaces.html"><strong aria-hidden="true">8.3.</strong> 损坏表面</a></li><li class="chapter-item expanded "><a href="../8-surfaces-in-depth/surface-regions.html"><strong aria-hidden="true">8.4.</strong> 表面区域</a></li><li class="chapter-item expanded "><a href="../8-surfaces-in-depth/subsurfaces.html"><strong aria-hidden="true">8.5.</strong> 子表面</a></li><li class="chapter-item expanded "><a href="../8-surfaces-in-depth/hidpi.html"><strong aria-hidden="true">8.6.</strong> 高分辨率表面（HiDPI）</a></li></ol></li><li class="chapter-item expanded "><a href="../9-seat/index.html"><strong aria-hidden="true">9.</strong> Seats 处理输入</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../9-seat/pointer.html"><strong aria-hidden="true">9.1.</strong> 光标指针输入</a></li><li class="chapter-item expanded "><a href="../9-seat/xkb.html"><strong aria-hidden="true">9.2.</strong> XBK 简介</a></li><li class="chapter-item expanded "><a href="../9-seat/keyboard.html"><strong aria-hidden="true">9.3.</strong> 键盘输入</a></li><li class="chapter-item expanded "><a href="../9-seat/touch.html"><strong aria-hidden="true">9.4.</strong> 触控输入</a></li><li class="chapter-item expanded "><a href="../9-seat/example.html" class="active"><strong aria-hidden="true">9.5.</strong> 扩展示例代码</a></li></ol></li><li class="chapter-item expanded "><a href="../10-xdg-shell-in-depth/index.html"><strong aria-hidden="true">10.</strong> 深入理解 XDG Shell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10-xdg-shell-in-depth/configuration.html"><strong aria-hidden="true">10.1.</strong> 配置和生命周期</a></li><li class="chapter-item expanded "><a href="../10-xdg-shell-in-depth/popups.html"><strong aria-hidden="true">10.2.</strong> 弹出窗口</a></li><li class="chapter-item expanded "><a href="../10-xdg-shell-in-depth/interactive.html"><strong aria-hidden="true">10.3.</strong> 交互式移动和尺寸调整</a></li><li class="chapter-item expanded "><a href="../10-xdg-shell-in-depth/positioners.html"><strong aria-hidden="true">10.4.</strong> 指针</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Clipboard access</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> Data offers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> Drag & drop</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Protocol extensions</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Accurate timing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Pointer constraints</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> Extended clipboard support</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.4.</strong> Desktop shell components</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.5.</strong> Miscellaneous extensions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.6.</strong> Writing new extensions</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Wayland Protocol 中文版</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ArkToria/the_wayland_protocol_zh_CN" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ArkToria/the_wayland_protocol_zh_CN/edit/main/docs/9-seat/example.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="扩展我们的示例代码"><a class="header" href="#扩展我们的示例代码">扩展我们的示例代码</a></h1>
<p>在前面几章中，我们建立了一个简单的客户端，它可以在显示器上展示其表面。让我们把这个代码扩展一下，建立一个可以接收输入事件的客户端。为了简单起见，我们仅仅将输入事件记录到 stderr。</p>
<p>这需要更多的代码，而不仅仅是将到目前为止的工作绑在一起。我们需要做的第一件事就是设置座位。</p>
<h2 id="设置座位"><a class="header" href="#设置座位">设置座位</a></h2>
<p>我们首先需要的是一个对座位的引用。我们将把它添加到我们的 <code>client_state</code> 结构体中，并添加键盘、指针和触摸对象供后期使用。</p>
<pre><code class="language-diff">        struct wl_shm *wl_shm;
        struct wl_compositor *wl_compositor;
        struct xdg_wm_base *xdg_wm_base;
+       struct wl_seat *wl_seat;
        /* Objects */
        struct wl_surface *wl_surface;
        struct xdg_surface *xdg_surface;
+       struct wl_keyboard *wl_keyboard;
+       struct wl_pointer *wl_pointer;
+       struct wl_touch *wl_touch;
        /* State */
        float offset;
        uint32_t last_frame;
        int width, height;
</code></pre>
<p>我们还需要更新 <code>registry_global</code>，为该座位注册一个监听器。</p>
<pre><code class="language-diff">                                wl_registry, name, &amp;xdg_wm_base_interface, 1);
                xdg_wm_base_add_listener(state-&gt;xdg_wm_base,
                                &amp;xdg_wm_base_listener, state);
+       } else if (strcmp(interface, wl_seat_interface.name) == 0) {
+               state-&gt;wl_seat = wl_registry_bind(
+                               wl_registry, name, &amp;wl_seat_interface, 7);
+               wl_seat_add_listener(state-&gt;wl_seat,
+                               &amp;wl_seat_listener, state);
        }
 }
</code></pre>
<p>请注意，我们绑定的是最新版本的座位接口，即第 7 版。让我们把监听器也加上：</p>
<pre><code class="language-c">static void
wl_seat_capabilities(void *data, struct wl_seat *wl_seat, uint32_t capabilities)
{
       struct client_state *state = data;
       /* TODO */
}

static void
wl_seat_name(void *data, struct wl_seat *wl_seat, const char *name)
{
       fprintf(stderr, &quot;seat name: %s\n&quot;, name);
}

static const struct wl_seat_listener wl_seat_listener = {
       .capabilities = wl_seat_capabilities,
       .name = wl_seat_name,
};
</code></pre>
<p>如果你现在编译 <code>(cc -o client client.c xdg-shell-protocol.c)</code> 并运行这个，你的座位名字就应该被打印到 stderr。</p>
<h2 id="接入指针事件"><a class="header" href="#接入指针事件">接入指针事件</a></h2>
<p>让我们来谈谈光标指针事件。如果你还记得，前面我们提到来自 Wayland 服务端的指针事件会被累积为一个单一逻辑事件。因此，我们需要定义一个结构体来存储这些事件。</p>
<pre><code class="language-c">enum pointer_event_mask {
       POINTER_EVENT_ENTER = 1 &lt;&lt; 0,
       POINTER_EVENT_LEAVE = 1 &lt;&lt; 1,
       POINTER_EVENT_MOTION = 1 &lt;&lt; 2,
       POINTER_EVENT_BUTTON = 1 &lt;&lt; 3,
       POINTER_EVENT_AXIS = 1 &lt;&lt; 4,
       POINTER_EVENT_AXIS_SOURCE = 1 &lt;&lt; 5,
       POINTER_EVENT_AXIS_STOP = 1 &lt;&lt; 6,
       POINTER_EVENT_AXIS_DISCRETE = 1 &lt;&lt; 7,
};

struct pointer_event {
       uint32_t event_mask;
       wl_fixed_t surface_x, surface_y;
       uint32_t button, state;
       uint32_t time;
       uint32_t serial;
       struct {
               bool valid;
               wl_fixed_t value;
               int32_t discrete;
       } axes[2];
       uint32_t axis_source;
};
</code></pre>
<p>这里我们使用一个位掩码来识别我们接受到的单个指针帧中的事件，并将每个事件的相关信息存储到各自的字段中。让我们也将此添加到我们的状态结构体中：</p>
<pre><code class="language-diff">        /* State */
        float offset;
        uint32_t last_frame;
        int width, height;
        bool closed;
+       struct pointer_event pointer_event;
 };
</code></pre>
<p>然后我们需要更新我们的 <code>wl_seat_capabilities</code>，为有光标指针输入功能的座位指定指针对象。</p>
<pre><code class="language-diff"> static void
 wl_seat_capabilities(void *data, struct wl_seat *wl_seat, uint32_t capabilities)
 {
        struct client_state *state = data;
-       /* TODO */
+
+       bool have_pointer = capabilities &amp; WL_SEAT_CAPABILITY_POINTER;
+
+       if (have_pointer &amp;&amp; state-&gt;wl_pointer == NULL) {
+               state-&gt;wl_pointer = wl_seat_get_pointer(state-&gt;wl_seat);
+               wl_pointer_add_listener(state-&gt;wl_pointer,
+                               &amp;wl_pointer_listener, state);
+       } else if (!have_pointer &amp;&amp; state-&gt;wl_pointer != NULL) {
+               wl_pointer_release(state-&gt;wl_pointer);
+               state-&gt;wl_pointer = NULL;
+       }
}
</code></pre>
<p>这里值得解释一下。回想一下，功能 <code>capabilities</code> 是此座位支持的设备类型的位掩码，即如果支持，则进行位与运算 (&amp;) 将产生非零值。然后，如果我们有一个光标指针，并且还没有配置它，我们就访问第一个分支 (第一个 if)，使用 <code>wl_seat_get_pointer</code> 来分配一个光标指针的引用并将它存储在我们的状态 (state) 中。如果座位不支持光标指针，但我们却已经配置了一个，那么需要使用 <code>wl_pointer_release</code> 来释放这个引用。请记住，一个座位的 <code>capabilities</code> 可能在运行时改变，例如，当用户重新插拔他们的鼠标时座位所拥有的功能就会改变。</p>
<p>我们还为指针配置了一个监听器。让我们将它也添加到结构体中：</p>
<pre><code class="language-c">static const struct wl_pointer_listener wl_pointer_listener = {
       .enter = wl_pointer_enter,
       .leave = wl_pointer_leave,
       .motion = wl_pointer_motion,
       .button = wl_pointer_button,
       .axis = wl_pointer_axis,
       .frame = wl_pointer_frame,
       .axis_source = wl_pointer_axis_source,
       .axis_stop = wl_pointer_axis_stop,
       .axis_discrete = wl_pointer_axis_discrete,
};
</code></pre>
<p>指针拥有许多事件，让我们来看看它们。</p>
<pre><code class="language-c">static void
wl_pointer_enter(void *data, struct wl_pointer *wl_pointer,
               uint32_t serial, struct wl_surface *surface,
               wl_fixed_t surface_x, wl_fixed_t surface_y)
{
       struct client_state *client_state = data;
       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_ENTER;
       client_state-&gt;pointer_event.serial = serial;
       client_state-&gt;pointer_event.surface_x = surface_x,
               client_state-&gt;pointer_event.surface_y = surface_y;
}

static void
wl_pointer_leave(void *data, struct wl_pointer *wl_pointer,
               uint32_t serial, struct wl_surface *surface)
{
       struct client_state *client_state = data;
       client_state-&gt;pointer_event.serial = serial;
       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_LEAVE;
}
</code></pre>
<p>进入 &quot;enter&quot; 和离开 &quot;leave&quot; 事件是非常直截了当的，它们为其余的执行工作提供了舞台。我们更新事件掩码以包括适当的事件，然后用我们提供的数据填充进去。运动 &quot;motion&quot; 和按钮 &quot;button&quot; 事件也是十分类似的：</p>
<pre><code class="language-c">static void
wl_pointer_motion(void *data, struct wl_pointer *wl_pointer, uint32_t time,
               wl_fixed_t surface_x, wl_fixed_t surface_y)
{
       struct client_state *client_state = data;
       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_MOTION;
       client_state-&gt;pointer_event.time = time;
       client_state-&gt;pointer_event.surface_x = surface_x,
               client_state-&gt;pointer_event.surface_y = surface_y;
}

static void
wl_pointer_button(void *data, struct wl_pointer *wl_pointer, uint32_t serial,
               uint32_t time, uint32_t button, uint32_t state)
{
       struct client_state *client_state = data;
       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_BUTTON;
       client_state-&gt;pointer_event.time = time;
       client_state-&gt;pointer_event.serial = serial;
       client_state-&gt;pointer_event.button = button,
               client_state-&gt;pointer_event.state = state;
}
</code></pre>
<p>轴事件有点复杂，因为存在两个方向的轴：水平和垂直。因此，我们的 <code>pointer_event</code> 结构体也包含具有两组轴事件的数组。我们处理这些的代码最终如下：</p>
<pre><code class="language-c">static void
wl_pointer_axis(void *data, struct wl_pointer *wl_pointer, uint32_t time,
               uint32_t axis, wl_fixed_t value)
{
       struct client_state *client_state = data;
       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_AXIS;
       client_state-&gt;pointer_event.time = time;
       client_state-&gt;pointer_event.axes[axis].valid = true;
       client_state-&gt;pointer_event.axes[axis].value = value;
}

static void
wl_pointer_axis_source(void *data, struct wl_pointer *wl_pointer,
               uint32_t axis_source)
{
       struct client_state *client_state = data;
       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_AXIS_SOURCE;
       client_state-&gt;pointer_event.axis_source = axis_source;
}

static void
wl_pointer_axis_stop(void *data, struct wl_pointer *wl_pointer,
               uint32_t time, uint32_t axis)
{
       struct client_state *client_state = data;
       client_state-&gt;pointer_event.time = time;
       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_AXIS_STOP;
       client_state-&gt;pointer_event.axes[axis].valid = true;
}

static void
wl_pointer_axis_discrete(void *data, struct wl_pointer *wl_pointer,
               uint32_t axis, int32_t discrete)
{
       struct client_state *client_state = data;
       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_AXIS_DISCRETE;
       client_state-&gt;pointer_event.axes[axis].valid = true;
       client_state-&gt;pointer_event.axes[axis].discrete = discrete;
}
</code></pre>
<p>除了更新受到影响的轴这一主要变化之外，其余部分也同样非常直截了当。请注意 &quot;valid&quot; 布尔值的使用：我们有可能受到更新了一个轴但没更新另一个的指针帧 (pointer frame)，所以我们使用 &quot;valid&quot; 值来确定该帧事件中哪些轴被有效更新。</p>
<p>说到这里，现在是该集中注意力的地方了：我们的 &quot;frame&quot; 句柄。</p>
<pre><code class="language-c">static void
wl_pointer_frame(void *data, struct wl_pointer *wl_pointer)
{
       struct client_state *client_state = data;
       struct pointer_event *event = &amp;client_state-&gt;pointer_event;
       fprintf(stderr, &quot;pointer frame @ %d: &quot;, event-&gt;time);

       if (event-&gt;event_mask &amp; POINTER_EVENT_ENTER) {
               fprintf(stderr, &quot;entered %f, %f &quot;,
                               wl_fixed_to_double(event-&gt;surface_x),
                               wl_fixed_to_double(event-&gt;surface_y));
       }

       if (event-&gt;event_mask &amp; POINTER_EVENT_LEAVE) {
               fprintf(stderr, &quot;leave&quot;);
       }

       if (event-&gt;event_mask &amp; POINTER_EVENT_MOTION) {
               fprintf(stderr, &quot;motion %f, %f &quot;,
                               wl_fixed_to_double(event-&gt;surface_x),
                               wl_fixed_to_double(event-&gt;surface_y));
       }

       if (event-&gt;event_mask &amp; POINTER_EVENT_BUTTON) {
               char *state = event-&gt;state == WL_POINTER_BUTTON_STATE_RELEASED ?
                       &quot;released&quot; : &quot;pressed&quot;;
               fprintf(stderr, &quot;button %d %s &quot;, event-&gt;button, state);
       }

       uint32_t axis_events = POINTER_EVENT_AXIS
               | POINTER_EVENT_AXIS_SOURCE
               | POINTER_EVENT_AXIS_STOP
               | POINTER_EVENT_AXIS_DISCRETE;
       char *axis_name[2] = {
               [WL_POINTER_AXIS_VERTICAL_SCROLL] = &quot;vertical&quot;,
               [WL_POINTER_AXIS_HORIZONTAL_SCROLL] = &quot;horizontal&quot;,
       };
       char *axis_source[4] = {
               [WL_POINTER_AXIS_SOURCE_WHEEL] = &quot;wheel&quot;,
               [WL_POINTER_AXIS_SOURCE_FINGER] = &quot;finger&quot;,
               [WL_POINTER_AXIS_SOURCE_CONTINUOUS] = &quot;continuous&quot;,
               [WL_POINTER_AXIS_SOURCE_WHEEL_TILT] = &quot;wheel tilt&quot;,
       };
       if (event-&gt;event_mask &amp; axis_events) {
               for (size_t i = 0; i &lt; 2; ++i) {
                       if (!event-&gt;axes[i].valid) {
                               continue;
                       }
                       fprintf(stderr, &quot;%s axis &quot;, axis_name[i]);
                       if (event-&gt;event_mask &amp; POINTER_EVENT_AXIS) {
                               fprintf(stderr, &quot;value %f &quot;, wl_fixed_to_double(
                                                       event-&gt;axes[i].value));
                       }
                       if (event-&gt;event_mask &amp; POINTER_EVENT_AXIS_DISCRETE) {
                               fprintf(stderr, &quot;discrete %d &quot;,
                                               event-&gt;axes[i].discrete);
                       }
                       if (event-&gt;event_mask &amp; POINTER_EVENT_AXIS_SOURCE) {
                               fprintf(stderr, &quot;via %s &quot;,
                                               axis_source[event-&gt;axis_source]);
                       }
                       if (event-&gt;event_mask &amp; POINTER_EVENT_AXIS_STOP) {
                               fprintf(stderr, &quot;(stopped) &quot;);
                       }
               }
       }

       fprintf(stderr, &quot;\n&quot;);
       memset(event, 0, sizeof(*event));
}
</code></pre>
<p>毋庸置疑，这是最长的一串代码了。但愿它不会令人感到困惑。我们在这里所做的就是把这一帧期间累积的状态漂亮地打印到 stderr 上。如果你现在再编译并运行这个程序，你应该可以在窗口上晃动你的鼠标，并看到输入事件被打印出来!</p>
<h2 id="接入键盘事件"><a class="header" href="#接入键盘事件">接入键盘事件</a></h2>
<p>让我们用一些字段更新我们的 <code>client_state</code> 结构，以存储 XKB 的状态。</p>
<pre><code class="language-diff">@@ -105,6 +107,9 @@ struct client_state {
        int width, height;
        bool closed;
        struct pointer_event pointer_event;
+       struct xkb_state *xkb_state;
+       struct xkb_context *xkb_context;
+       struct xkb_keymap *xkb_keymap;
};
</code></pre>
<p>我们需要 <code>xkbcommon</code> 头文件来定义这些。通常当我们这样做的时候，我将会把 <code>assert.h</code> 也拉进来。</p>
<pre><code class="language-diff">@@ -1,4 +1,5 @@
 #define _POSIX_C_SOURCE 200112L
+#include &lt;assert.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;limits.h&gt;
@@ -9,6 +10,7 @@
 #include &lt;time.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;wayland-client.h&gt;
+#include &lt;xkbcommon/xkbcommon.h&gt;
 #include &quot;xdg-shell-client-protocol.h&quot;
</code></pre>
<p>我们还需要在我们的主函数中初始化 <code>xkb_context</code>:</p>
<pre><code class="language-diff">@@ -603,6 +649,7 @@ main(int argc, char *argv[])
        state.height = 480;
        state.wl_display = wl_display_connect(NULL);
        state.wl_registry = wl_display_get_registry(state.wl_display);
+       state.xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
        wl_registry_add_listener(state.wl_registry, &amp;wl_registry_listener, &amp;state);
        wl_display_roundtrip(state.wl_display);
</code></pre>
<p>下一步，让我们来更新我们座位的功能函数，把我们的键盘监听器也接入。</p>
<pre><code class="language-diff">        } else if (!have_pointer &amp;&amp; state-&gt;wl_pointer != NULL) {
                wl_pointer_release(state-&gt;wl_pointer);
                state-&gt;wl_pointer = NULL;
        }
+
+       bool have_keyboard = capabilities &amp; WL_SEAT_CAPABILITY_KEYBOARD;
+
+       if (have_keyboard &amp;&amp; state-&gt;wl_keyboard == NULL) {
+               state-&gt;wl_keyboard = wl_seat_get_keyboard(state-&gt;wl_seat);
+               wl_keyboard_add_listener(state-&gt;wl_keyboard,
+                               &amp;wl_keyboard_listener, state);
+       } else if (!have_keyboard &amp;&amp; state-&gt;wl_keyboard != NULL) {
+               wl_keyboard_release(state-&gt;wl_keyboard);
+               state-&gt;wl_keyboard = NULL;
+       }
 }
</code></pre>
<p>我们也要在这里定义我们使用的 <code>wl_keyboard_listener</code>。</p>
<pre><code class="language-c">static const struct wl_keyboard_listener wl_keyboard_listener = {
       .keymap = wl_keyboard_keymap,
       .enter = wl_keyboard_enter,
       .leave = wl_keyboard_leave,
       .key = wl_keyboard_key,
       .modifiers = wl_keyboard_modifiers,
       .repeat_info = wl_keyboard_repeat_info,
};
</code></pre>
<p>现在开始有了一些变化，让我们从 keymap 开始：</p>
<pre><code class="language-c">static void
wl_keyboard_keymap(void *data, struct wl_keyboard *wl_keyboard,
               uint32_t format, int32_t fd, uint32_t size)
{
       struct client_state *client_state = data;
       assert(format == WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1);

       char *map_shm = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
       assert(map_shm != MAP_FAILED);

       struct xkb_keymap *xkb_keymap = xkb_keymap_new_from_string(
                       client_state-&gt;xkb_context, map_shm,
                       XKB_KEYMAP_FORMAT_TEXT_V1, XKB_KEYMAP_COMPILE_NO_FLAGS);
       munmap(map_shm, size);
       close(fd);

       struct xkb_state *xkb_state = xkb_state_new(xkb_keymap);
       xkb_keymap_unref(client_state-&gt;xkb_keymap);
       xkb_state_unref(client_state-&gt;xkb_state);
       client_state-&gt;xkb_keymap = xkb_keymap;
       client_state-&gt;xkb_state = xkb_state;
}
</code></pre>
<p>现在我们可以看到为什么我们需要添加 <code>assert.h</code>——我们在这里用断言来确保 keymap 的格式是我们所期望的。然后，我们用 mmap 将混成器发送给我们的文件描述符 fd 映射成一个 <code>char*</code> 指针，我们可以将其传入 <code>xkb_keymap_new_from_string</code>。不要忘记 <code>munmap</code> 并在之后关闭这个文件描述符，然后设置我们的 XKB 状态。还要注意的是，我们也用 &quot;*_unref&quot; 去掉了先前在调用此函数时所设置的一切 XKB keymap 或 state 引用，以防混成器在运行时改变 keymap<sup class="footnote-reference"><a href="#1">1</a></sup>。</p>
<pre><code class="language-c">static void
wl_keyboard_enter(void *data, struct wl_keyboard *wl_keyboard,
               uint32_t serial, struct wl_surface *surface,
               struct wl_array *keys)
{
       struct client_state *client_state = data;
       fprintf(stderr, &quot;keyboard enter; keys pressed are:\n&quot;);
       uint32_t *key;
       wl_array_for_each(key, keys) {
               char buf[128];
               xkb_keysym_t sym = xkb_state_key_get_one_sym(
                               client_state-&gt;xkb_state, *key + 8);
               xkb_keysym_get_name(sym, buf, sizeof(buf));
               fprintf(stderr, &quot;sym: %-12s (%d), &quot;, buf, sym);
               xkb_state_key_get_utf8(client_state-&gt;xkb_state,
                               *key + 8, buf, sizeof(buf));
               fprintf(stderr, &quot;utf8: '%s'\n&quot;, buf);
       }
}
</code></pre>
<p>当键盘 &quot;进入&quot; 我们的表面时，我们已经获得了键盘的输入焦点。混成器会将这之前所按键的队列转发出来，这里我们只是枚举它们并记录它们的 keysym 名称和 UTF-8 等效值。当按键被按下的时候，我们会做类似如下的事情：</p>
<pre><code class="language-c">static void
wl_keyboard_key(void *data, struct wl_keyboard *wl_keyboard,
               uint32_t serial, uint32_t time, uint32_t key, uint32_t state)
{
       struct client_state *client_state = data;
       char buf[128];
       uint32_t keycode = key + 8;
       xkb_keysym_t sym = xkb_state_key_get_one_sym(
                       client_state-&gt;xkb_state, keycode);
       xkb_keysym_get_name(sym, buf, sizeof(buf));
       const char *action =
               state == WL_KEYBOARD_KEY_STATE_PRESSED ? &quot;press&quot; : &quot;release&quot;;
       fprintf(stderr, &quot;key %s: sym: %-12s (%d), &quot;, action, buf, sym);
       xkb_state_key_get_utf8(client_state-&gt;xkb_state, keycode,
                       buf, sizeof(buf));
       fprintf(stderr, &quot;utf8: '%s'\n&quot;, buf);
}
</code></pre>
<p>最后，我们增加了其余三个小事件的实现：</p>
<pre><code class="language-c">static void
wl_keyboard_leave(void *data, struct wl_keyboard *wl_keyboard,
               uint32_t serial, struct wl_surface *surface)
{
       fprintf(stderr, &quot;keyboard leave\n&quot;);
}

static void
wl_keyboard_modifiers(void *data, struct wl_keyboard *wl_keyboard,
               uint32_t serial, uint32_t mods_depressed,
               uint32_t mods_latched, uint32_t mods_locked,
               uint32_t group)
{
       struct client_state *client_state = data;
       xkb_state_update_mask(client_state-&gt;xkb_state,
               mods_depressed, mods_latched, mods_locked, 0, 0, group);
}

static void
wl_keyboard_repeat_info(void *data, struct wl_keyboard *wl_keyboard,
               int32_t rate, int32_t delay)
{
       /* Left as an exercise for the reader */
}
</code></pre>
<p>对于修饰符，我们可以进一步解码，但大多数应用程序不需要这样做。我们只是在这里更新 XKB 的状态。至于处理按键重复，这对于你的应用来说有诸多限制。比如，你想重复输入文本吗，想重复键盘快捷键吗，这些重复的所需的时间如何与你的事件循环进行互动？这些问题的答案需要由你自己来决定。</p>
<p>如果你再次编译并运行，你应该能够开始在窗口中开始打字，并看到你的输入被打印到终端日志中。这值得欢呼！</p>
<h2 id="接入触摸事件"><a class="header" href="#接入触摸事件">接入触摸事件</a></h2>
<p>最后，我们将新增设备的触摸功能支持。就和指针事件一样，触摸设备也存在一个 &quot;frame&quot; 帧事件。然而，由于有多个触摸点可能在一帧内被更新，所以它们可能变得更加复杂。我们将增加一些结构体和枚举类型来表示状态的累积。</p>
<pre><code class="language-c">enum touch_event_mask {
       TOUCH_EVENT_DOWN = 1 &lt;&lt; 0,
       TOUCH_EVENT_UP = 1 &lt;&lt; 1,
       TOUCH_EVENT_MOTION = 1 &lt;&lt; 2,
       TOUCH_EVENT_CANCEL = 1 &lt;&lt; 3,
       TOUCH_EVENT_SHAPE = 1 &lt;&lt; 4,
       TOUCH_EVENT_ORIENTATION = 1 &lt;&lt; 5,
};

struct touch_point {
       bool valid;
       int32_t id;
       uint32_t event_mask;
       wl_fixed_t surface_x, surface_y;
       wl_fixed_t major, minor;
       wl_fixed_t orientation;
};

struct touch_event {
       uint32_t event_mask;
       uint32_t time;
       uint32_t serial;
       struct touch_point points[10];
};
</code></pre>
<p>请注意，我在这里选择了 10 个触摸点，假设大多数用户只会使用这么多手指。而对于较大的多用户触摸屏，你可能需要一个更高的上限。此外，有些触摸硬件同时支持的触摸点少于十个，仅有八个也是常见的，而支持触摸点数量更少的硬件在老旧设备中也十分常见。</p>
<p>我们把这个结构体添加到 <code>client_state</code>:</p>
<pre><code class="language-diff">@@ -110,6 +135,7 @@ struct client_state {
        struct xkb_state *xkb_state;
        struct xkb_context *xkb_context;
        struct xkb_keymap *xkb_keymap;
+       struct touch_event touch_event;
 };
</code></pre>
<p>当触摸支持可用的时候，我们将更新座位的功能句柄，以介入一个监听器。</p>
<pre><code class="language-diff">        } else if (!have_keyboard &amp;&amp; state-&gt;wl_keyboard != NULL) {
                wl_keyboard_release(state-&gt;wl_keyboard);
                state-&gt;wl_keyboard = NULL;
        }
+
+       bool have_touch = capabilities &amp; WL_SEAT_CAPABILITY_TOUCH;
+
+       if (have_touch &amp;&amp; state-&gt;wl_touch == NULL) {
+               state-&gt;wl_touch = wl_seat_get_touch(state-&gt;wl_seat);
+               wl_touch_add_listener(state-&gt;wl_touch,
+                               &amp;wl_touch_listener, state);
+       } else if (!have_touch &amp;&amp; state-&gt;wl_touch != NULL) {
+               wl_touch_release(state-&gt;wl_touch);
+               state-&gt;wl_touch = NULL;
+       }
 }
</code></pre>
<p>我们对作为上触摸功能的出现和消失也做了同样处理，因此我们的代码在运行时设备热插拔处理方面都很健壮。不过，触摸设备热插拔的情况在实际中不太常见。</p>
<p>这里是其自身的监听器:</p>
<pre><code class="language-c">static const struct wl_touch_listener wl_touch_listener = {
       .down = wl_touch_down,
       .up = wl_touch_up,
       .motion = wl_touch_motion,
       .frame = wl_touch_frame,
       .cancel = wl_touch_cancel,
       .shape = wl_touch_shape,
       .orientation = wl_touch_orientation,
};
</code></pre>
<p>为了解决多点触摸问题，我们需要写一个小的辅助函数:</p>
<pre><code class="language-c">+static struct touch_point *
+get_touch_point(struct client_state *client_state, int32_t id)
+{
+       struct touch_event *touch = &amp;client_state-&gt;touch_event;
+       const size_t nmemb = sizeof(touch-&gt;points) / sizeof(struct touch_point);
+       int invalid = -1;
+       for (size_t i = 0; i &lt; nmemb; ++i) {
+               if (touch-&gt;points[i].id == id) {
+                       return &amp;touch-&gt;points[i];
+               }
+               if (invalid == -1 &amp;&amp; !touch-&gt;points[i].valid) {
+                       invalid = i;
+               }
+       }
+       if (invalid == -1) {
+               return NULL;
+       }
+       touch-&gt;points[invalid].valid = true;
+       touch-&gt;points[invalid].id = id;
+       return &amp;touch-&gt;points[invalid];
+}
</code></pre>
<p>这个函数的基本目的是从我们添加到 <code>touch_event</code> 结构体的数组中，根据我们要接收事件的触摸点 ID，挑选一个触摸点。如果我们找到了该 ID 的现有触摸点，我们就将其返回。如果没有，则会返回第一个可用的触摸点。如果我们都找完了还没有，就会返回 <code>NULL</code>。</p>
<p>现在我们可以利用这点来实现我们的第一个功能：触摸。</p>
<pre><code class="language-c">static void
wl_touch_down(void *data, struct wl_touch *wl_touch, uint32_t serial,
               uint32_t time, struct wl_surface *surface, int32_t id,
               wl_fixed_t x, wl_fixed_t y)
{
       struct client_state *client_state = data;
       struct touch_point *point = get_touch_point(client_state, id);
       if (point == NULL) {
               return;
       }
       point-&gt;event_mask |= TOUCH_EVENT_UP;
       point-&gt;surface_x = wl_fixed_to_double(x),
               point-&gt;surface_y = wl_fixed_to_double(y);
       client_state-&gt;touch_event.time = time;
       client_state-&gt;touch_event.serial = serial;
}
</code></pre>
<p>和指针事件一样，我们也是简单地将这个状态累积起来，以便后续使用。我们还不知道这个事件是否代表一个完整的触摸帧。让我们为触摸添加一些类似的东西：</p>
<pre><code class="language-c">static void
wl_touch_up(void *data, struct wl_touch *wl_touch, uint32_t serial,
               uint32_t time, int32_t id)
{
       struct client_state *client_state = data;
       struct touch_point *point = get_touch_point(client_state, id);
       if (point == NULL) {
               return;
       }
       point-&gt;event_mask |= TOUCH_EVENT_UP;
}
</code></pre>
<p>以及运动：</p>
<pre><code class="language-c">static void
wl_touch_motion(void *data, struct wl_touch *wl_touch, uint32_t time,
               int32_t id, wl_fixed_t x, wl_fixed_t y)
{
       struct client_state *client_state = data;
       struct touch_point *point = get_touch_point(client_state, id);
       if (point == NULL) {
               return;
       }
       point-&gt;event_mask |= TOUCH_EVENT_MOTION;
       point-&gt;surface_x = x, point-&gt;surface_y = y;
       client_state-&gt;touch_event.time = time;
}
</code></pre>
<p>触摸事件的取消与之前有所不同，因为它一次性 “取消” 了所有活动的触摸点。我们只需要将其存储在 <code>touch_event</code> 的顶层事件掩码中。</p>
<pre><code class="language-c">static void
wl_touch_cancel(void *data, struct wl_touch *wl_touch)
{
       struct client_state *client_state = data;
       client_state-&gt;touch_event.event_mask |= TOUCH_EVENT_CANCEL;
}
</code></pre>
<p>然而，形状和方向事件类似于向上、向下和移动，因为它们告诉我们一个特定触摸点的尺寸。</p>
<pre><code class="language-c">static void
wl_touch_shape(void *data, struct wl_touch *wl_touch,
               int32_t id, wl_fixed_t major, wl_fixed_t minor)
{
       struct client_state *client_state = data;
       struct touch_point *point = get_touch_point(client_state, id);
       if (point == NULL) {
               return;
       }
       point-&gt;event_mask |= TOUCH_EVENT_SHAPE;
       point-&gt;major = major, point-&gt;minor = minor;
}

static void
wl_touch_orientation(void *data, struct wl_touch *wl_touch,
               int32_t id, wl_fixed_t orientation)
{
       struct client_state *client_state = data;
       struct touch_point *point = get_touch_point(client_state, id);
       if (point == NULL) {
               return;
       }
       point-&gt;event_mask |= TOUCH_EVENT_ORIENTATION;
       point-&gt;orientation = orientation;
}
</code></pre>
<p>最后，在收到一个帧事件时，我们可以将所有这些累积的状态解释为一个单一的输入事件，就像我们的光标指针代码一样。</p>
<pre><code class="language-c">static void
wl_touch_frame(void *data, struct wl_touch *wl_touch)
{
       struct client_state *client_state = data;
       struct touch_event *touch = &amp;client_state-&gt;touch_event;
       const size_t nmemb = sizeof(touch-&gt;points) / sizeof(struct touch_point);
       fprintf(stderr, &quot;touch event @ %d:\n&quot;, touch-&gt;time);

       for (size_t i = 0; i &lt; nmemb; ++i) {
               struct touch_point *point = &amp;touch-&gt;points[i];
               if (!point-&gt;valid) {
                       continue;
               }
               fprintf(stderr, &quot;point %d: &quot;, touch-&gt;points[i].id);

               if (point-&gt;event_mask &amp; TOUCH_EVENT_DOWN) {
                       fprintf(stderr, &quot;down %f,%f &quot;,
                                       wl_fixed_to_double(point-&gt;surface_x),
                                       wl_fixed_to_double(point-&gt;surface_y));
               }

               if (point-&gt;event_mask &amp; TOUCH_EVENT_UP) {
                       fprintf(stderr, &quot;up &quot;);
               }

               if (point-&gt;event_mask &amp; TOUCH_EVENT_MOTION) {
                       fprintf(stderr, &quot;motion %f,%f &quot;,
                                       wl_fixed_to_double(point-&gt;surface_x),
                                       wl_fixed_to_double(point-&gt;surface_y));
               }

               if (point-&gt;event_mask &amp; TOUCH_EVENT_SHAPE) {
                       fprintf(stderr, &quot;shape %fx%f &quot;,
                                       wl_fixed_to_double(point-&gt;major),
                                       wl_fixed_to_double(point-&gt;minor));
               }

               if (point-&gt;event_mask &amp; TOUCH_EVENT_ORIENTATION) {
                       fprintf(stderr, &quot;orientation %f &quot;,
                                       wl_fixed_to_double(point-&gt;orientation));
               }

               point-&gt;valid = false;
               fprintf(stderr, &quot;\n&quot;);
       }
}
</code></pre>
<p>编译并再次运行这个程序，你就可以看到当你与触摸设备交互时，触摸事件被答应到 stderr （假设你现在有支持触摸的设备）。现在我们的客户端终于了实现输入的支持！</p>
<h2 id="接下来该做什么"><a class="header" href="#接下来该做什么">接下来该做什么？</a></h2>
<p>有很多不同种类的输入设备，因此扩展我们的代码以支持这些设备是一项相当庞大的工作——仅在本章中我们的代码量就增加了 2.5 倍。不过收获应该也是相当大的，因为你现在已经熟悉了足够多的 Wayland 概念（和代码），由此你可以实现多种多样的客户端了。</p>
<p>这之后还有更多的东西要学——在最后几章，我们将介绍弹出窗口、上下文菜单、交互式窗口的移动和大小调整、剪贴板和拖放支持，以及后来的一些有趣的扩展协议，以支持更多小众的使用场景。我强烈建议你在构建自己的客户端之前先读到第 10.1 章，因为它涵盖诸如根据混成器的要求调整窗口大小等内容。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>这种情况在实践中确实发生了！</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../9-seat/touch.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../10-xdg-shell-in-depth/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../9-seat/touch.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../10-xdg-shell-in-depth/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
