import{_ as e,c as a,o as i,d as t}from"./app.5f5b8589.js";const f=JSON.parse('{"title":"协议设计准则","description":"","frontmatter":{},"headers":[{"level":2,"title":"原子性","slug":"原子性","link":"#原子性","children":[]},{"level":2,"title":"资源生命周期","slug":"资源生命周期","link":"#资源生命周期","children":[]},{"level":2,"title":"版本控制","slug":"版本控制","link":"#版本控制","children":[]}],"relativePath":"2-protocol-design/design-patterns.md","lastUpdated":1674200399000}'),l={name:"2-protocol-design/design-patterns.md"},n=t('<h1 id="协议设计准则" tabindex="-1">协议设计准则 <a class="header-anchor" href="#协议设计准则" aria-hidden="true">#</a></h1><p>在大多数 Wayland 的协议设计中已经应用了一些关键性的概念，我们将在此简要介绍它们。在整个上层 Wayland 协议及其扩展协议中都可以找到这些准则（至少在 Wayland 协议中）。如果您正在编写自己当协议扩展，那么聪明的做法是借鉴这些准则。</p><h2 id="原子性" tabindex="-1">原子性 <a class="header-anchor" href="#原子性" aria-hidden="true">#</a></h2><p>Wayland 协议设计中最重要的准则就是原子性。Wayland 的既定目标是“每一帧都是完美的”。为此，大多数接口都允许以事务的方式进行更新，使用多个请求来创建一个新的表示状态，然后一次性提交所有请求。例如，可以在 <code>wl_surface</code> 上配置几个属性：</p><ul><li>附加的像素缓冲区</li><li>需要重新绘制的变更区域</li><li>出于优化而不透明的区域</li><li>可接受输入事件的区域</li><li>变形，例如旋转 90 度</li><li>缓冲规模，用于 HiDPI</li></ul><p>该接口为这些请求提供了独立的配置，但它们都处于挂起状态（pending）。仅当提交请求的时候，挂起状态才会合并到当前状态（current）。从而使您可以在单帧内原子地更新所有这些属性。结合其他一些关键性设计决策，Wayland 混成器可以在每一帧中完美地呈现所有内容——没有画面撕裂和窗口部分更新，每个像素都恰如其分地显示。</p><h2 id="资源生命周期" tabindex="-1">资源生命周期 <a class="header-anchor" href="#资源生命周期" aria-hidden="true">#</a></h2><p>另一个重要的设计准则是：避免服务端和客户端向无效对象发送相关事件或请求。于此，通过接口定义的事件和请求具有有限的生命周期，服务端和客户端也可以通过接口对其进行显式释放。只有当两边都先后同意才能释放对象所分配的资源。</p><p>Wayland 是一个完全异步的协议。它将保证消息按发送顺序送达，但仅仅针对一个发送者的情况。例如，当客户端决定销毁其键盘设备时，服务端可能会有多个输入事件正在排队。客户端必须正确处理不再需要的对象事件，直到服务端同步。同理，如果客户端在销毁对象前将一些不再需要的请求入队，则服务端必须以正确的顺序发送这些请求，以便在客户端同意销毁该对象后不再对其进行使用。</p><h2 id="版本控制" tabindex="-1">版本控制 <a class="header-anchor" href="#版本控制" aria-hidden="true">#</a></h2>',10),d=[n];function r(s,c,o,h,_,p){return i(),a("div",null,d)}const g=e(l,[["render",r]]);export{f as __pageData,g as default};
