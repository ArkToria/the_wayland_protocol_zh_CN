import{_ as e,c as o,o as i,d as t}from"./app.7c3264b1.js";const D=JSON.parse('{"title":"基础 Wire 协议","description":"","frontmatter":{},"headers":[{"level":2,"title":"消息","slug":"消息","link":"#消息","children":[]},{"level":2,"title":"对象 ID","slug":"对象-id","link":"#对象-id","children":[]},{"level":2,"title":"传输","slug":"传输","link":"#传输","children":[]}],"relativePath":"2-protocol-design/wire-protocol.md","lastUpdated":1675327495000}'),r={name:"2-protocol-design/wire-protocol.md"},l=t('<h1 id="基础-wire-协议" tabindex="-1">基础 Wire 协议 <a class="header-anchor" href="#基础-wire-协议" aria-hidden="true">#</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果仅仅打算使用 <code>libwayland</code>，那么本节选读，直接跳至下节。</p></div><p>Wire 协议是由 32 位值所组成的流，使用当前机器的字节顺序进行编码（例如 x86 系列 CPU 上的小端序）。 其中包含以下几种基础类型：</p><ul><li><strong>int</strong> <strong>uint</strong><br> 32 位 有符号及无符号整型</li><li><strong>fixed</strong><br> 24 位整数 + 8 位小数 有符号浮点数</li><li><strong>object</strong><br> 32 位 对象 ID</li><li><strong>new_id</strong><br> 32 位 对象 ID（收到对象时需要分配）</li></ul><p>除了上述基础类型之外，还有一些常用的类型：</p><ul><li><p><strong>string</strong><br> 字符串以 32 位整数开头，这个整数表示字符串的长度（以字节为单位）， 接下来是字符串的内容和 NUL 终结符，最后用未定义数据对齐填充 32 位。 编码没有指定，但是实际使用 UTF-8。</p></li><li><p><strong>array</strong><br> 任意数据的二进制块，以 32 位整数开头，指定块长度（以字节为单位）， 然后是数组的逐字内容，最后用未定义数据对齐 32 位。</p></li><li><p><strong>fd</strong><br> 主传输上的 0 位值，在 Unix socket 消息（msg_control）中使用辅助数据，将文件描述符从一端传输到另一端。</p></li><li><p><strong>enum</strong><br> 一个单独的值（或 bitmap），用于已知常量的枚举，编码为 32 位整型。</p></li></ul><h2 id="消息" tabindex="-1">消息 <a class="header-anchor" href="#消息" aria-hidden="true">#</a></h2><p>Wire 协议是使用这些原语构建而成的消息流。 每条消息都代表着某个对象 object 相关的一次 event 事件（服务端到客户端）或 request 请求 （客户端到服务端）。</p><p>消息头由两个字段组成。 第一个字段是操作的对象 ID。 第二个字段是两个 16 位值：高 16 位是这条消息的大小（包括头本身），低 16 位是这次事件或请求的操作码。 接下来是基于双方事先约定的消息签名的消息参数。 接收方会查找对象 ID 的接口、事件或请求的操作码，以确认消息的签名和属性。</p><p>为了解析一条消息，客户端和服务端必须先创建对象。 ID 1 预分配给了 Wayland 显示单例对象，它被用于引导产生其它对象。 我们将在第四章中对此进行讨论。 下一章将假设您已经有了一个对象 ID，进一步讨论什么是接口、请求和事件怎么运行。</p><h2 id="对象-id" tabindex="-1">对象 ID <a class="header-anchor" href="#对象-id" aria-hidden="true">#</a></h2><p>当 <code>new_id</code> 参数随某条消息而来，发送者会给它分配一个对象 ID （新对象的接口通过其它额外的参数传递，或事先双方约定）。 此对象 ID 能在后续的消息头或者其它对象的参数中使用。 客户端在 <code>[1, 0xFEFFFFFF]</code> 而服务端在 <code>[0xFF000000, 0xFFFFFFFF]</code> 内分配 ID。 ID 从低位边界开始，并随每次新对象的分配递增。</p><p>对象的 ID 为 0 代表 null 空对象，即不存在或者空缺。</p><h2 id="传输" tabindex="-1">传输 <a class="header-anchor" href="#传输" aria-hidden="true">#</a></h2><p>迄今为止，所有的 Wayland 实现均通过 Unix socket 工作。 这有个很特别的原因：文件描述符消息。 Unix socket 是最实用的跨进程文件描述符传输方法，它对大文件传输（如键盘映射、像素缓冲区、剪切板）非常必要。 理论上其它传输协议（比 TCP）可行，但是需要开发者实现大文件传输的替代方案。</p><p>为了找到 Unix socket 连接，大部分实现和 libwayland 操作一样：</p><ol><li>如果 <code>WAYLAND_SOCKET</code> 已设置，则假设父进程已经为我们配置了连接，将 <code>WAYLAND_SOCKET</code> 解析为文件描述符。</li><li>如果 <code>WAYLAND_DISPLAY</code> 已设置，则与 <code>XDG_RUNTIME_DIR</code> 路径连接，尝试建立 Unix socket。</li><li>假设 socket 名称为 <code>wayland-0</code> 并连接 <code>XDG_RUNTIME_DIR</code> 为路径，尝试建立 Unix socket。</li><li>失败放弃。</li></ol>',17),n=[l];function d(a,c,s,p,_,h){return i(),o("div",null,n)}const u=e(r,[["render",d]]);export{D as __pageData,u as default};
