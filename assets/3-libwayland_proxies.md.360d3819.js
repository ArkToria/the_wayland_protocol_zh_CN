import{_ as s,c as a,o as n,d as l}from"./app.9965651d.js";const C=JSON.parse('{"title":"代理与资源","description":"","frontmatter":{},"headers":[],"relativePath":"3-libwayland/proxies.md","lastUpdated":1674200399000}'),o={name:"3-libwayland/proxies.md"},e=l(`<h1 id="代理与资源" tabindex="-1">代理与资源 <a class="header-anchor" href="#代理与资源" aria-hidden="true">#</a></h1><p>对象是客户端和服务端都知道的具有某种状态的实体，通过线协议协商来对其进行更改。在客户端，<code>libwayland</code> 通过 <code>wl_proxy</code> 接口引用这些对象。这些接口是对 C 语言友好的，是抽象对象的具体“代理”，并为客户端提供了间接函数，以将请求编组转化为线协议格式。如果你查看 <code>wayland-client.core.h</code> 文件，会发现一些实现该目的的底层函数。而通常你不会直接使用它们。</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// /usr/include/wayland-client-core.h</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">wl_proxy_marshal</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> wl_proxy </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;font-style:italic;">p</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">uint32_t</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">opcode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> wl_proxy </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">wl_proxy_create</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> wl_proxy </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;font-style:italic;">factory</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> wl_interface </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;font-style:italic;">interface</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"></span></code></pre></div><p>在服务端，对象是通过 <code>wl_resource</code> 抽象的，这与客户端非常相似，但另有更复杂的内容——服务端必须跟踪哪个对象属于哪个客户端。每个 <code>wl_resource</code> 均由单个客户端所有。除此之外，该这两个接口基本相同，并且为编组事件发送到关联的客户端提供了底层的抽象。与直接在客户端上使用 <code>wl_proxy</code> 相比，直接在服务端上使用 <code>wl_resource</code> 的频率更高。这种用法的一个例子是获取对 <code>wl_client</code> 的引用，该 <code>wl_client</code> 拥有你所在上下文之外的操作资源，或者在客户端尝试无效操作的时候发送协议错误。</p><p>此外还有另一组高级接口，大多数 Wayland 客户端和服务端的代码都与之交互以完成其大部分任务。</p>`,5),p=[e];function t(c,r,y,i,d,A){return n(),a("div",null,p)}const D=s(o,[["render",t]]);export{C as __pageData,D as default};
