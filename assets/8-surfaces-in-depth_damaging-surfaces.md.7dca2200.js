import{_ as a,c as s,o as e,d as n}from"./app.1dfb0975.js";const y=JSON.parse('{"title":"损坏表面","description":"","frontmatter":{},"headers":[],"relativePath":"8-surfaces-in-depth/damaging-surfaces.md","lastUpdated":1677168613000}'),o={name:"8-surfaces-in-depth/damaging-surfaces.md"},t=n(`<h1 id="损坏表面" tabindex="-1">损坏表面 <a class="header-anchor" href="#损坏表面" aria-hidden="true">#</a></h1><p>你可能已经注意到，在上一个例子中，当我们向表面提交一个新的帧的时候，在代码中添加了这样一行：</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#82AAFF;">wl_surface_damage_buffer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;font-style:italic;">wl_surface</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> INT32_MAX</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> INT32_MAX</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre></div><p>如果是这样的话，请擦亮眼睛！这段代码损坏了我们的表面，向混成器表明其需要重新被绘制。在这里，我们损坏了整个表面（甚至远远超过其范围），但我们也可以只损坏其中的一部分。</p><p>例如，你写了一个 GUI 工具，用户正在向一个文本框中输入信息。这个文本框可能只占窗口的一小部分，而每个新的字符所占的部分就更小了。当用户按下一个按键，你可以只渲染文本上的新字符，然后只标记表面的那一部分即可。然后，混成器可以只复制表面的一小部分，这可以大大加快速度——特别是对于嵌入式设备。当光标在字符之间闪烁的时候，你仅需要提交更新部分的损坏，而当用户改变视图的时候，才可能会损坏整个表面。这样，每项改动的开销都减少了，并且用户会感谢你提高了他们的电池寿命。</p><p><strong>注意：</strong> Wayland 协议为破坏表面提供了两个请求 <code>damage</code> 和 <code>damage_buffer</code>。前者实际上已经弃用了，你应该只使用后者。二者的区别在于，<code>damage</code> 考虑到了影响曲面的所有变换，比如旋转、缩放比例、缓冲区位置和剪切。后者则是相对于缓冲区标记损坏，这样更容易解释。</p>`,6),p=[t];function c(l,r,d,_,i,D){return e(),s("div",null,p)}const C=a(o,[["render",c]]);export{y as __pageData,C as default};
