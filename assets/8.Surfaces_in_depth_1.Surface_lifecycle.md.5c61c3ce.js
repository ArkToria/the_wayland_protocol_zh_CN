import{_ as e,c as o,o as c,d as t}from"./app.9965651d.js";const h=JSON.parse('{"title":"表面的生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"8.Surfaces_in_depth/1.Surface_lifecycle.md","lastUpdated":1673863362000}'),a={name:"8.Surfaces_in_depth/1.Surface_lifecycle.md"},s=t('<h1 id="表面的生命周期" tabindex="-1">表面的生命周期 <a class="header-anchor" href="#表面的生命周期" aria-hidden="true">#</a></h1><p>我们在前面提到，Wayland 的设计是为了原子化地更新所有的东西，这样就不会有无效或者中间状态的帧出现。正是 <code>wl_surface</code> 本身的机制保障了应用程序窗口和其他表面多种属性配置时原子性。</p><p>每个表面都有一个待定状态和一个应用状态，而在它刚被创建的时候则无任何状态。待定状态是通过客户端的请求和服务端的事件来协商的，当双方都认为它代表一个一致的表面状态时，表面就会被提交——待定状态会被应用到表面的当前状态。在这之前，混成器将继续渲染最后的一致状态；一旦提交，将从下一帧开始使用新的状态。</p><p>其中原子操作更新的状态有：</p><ul><li>所附加的 <code>wl_buffer</code> 或构成表面内容的像素</li><li>在上一帧中被 “破坏” 的区域，需要重新绘制。</li><li>接受输入事件的区域。</li><li>被认为是不透明的区域 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li><li>对附加的 <code>wl_buffer</code> 进行变换，以旋转或呈现缓冲区的一个子集</li><li>缓冲区的缩放系数，用于高分辨率 (HiDPI) 显示。</li></ul><p>除了表面的这些特征之外，表面的角色还可以有额外的双缓冲区。所有这些状态，以及与角色相关的任何状态，都会在发达送 <code>wl_surface.commit</code> 时应用。如果你改变主意，你可以多次发送这些请求，当表面最终被提交的时候只会考虑这些属性的最新值（即可最后一次提交有效）。</p><p>当你第一次创建表面时，初始状态是无效的。为了使其有效（或映射到表面），你需要提供必要的信息来初次为该曲面建立一致的状态。这包括给它一个角色（比如 <code>xdg_toplevel</code>），分配和附加一个缓冲区，以及配置该表面的任何角色特定状态。当你发送了一个 <code>wl_surface.commit</code> 并正确配置了这个状态时，这个表面就会生效（或被映射）并被混成器呈现。</p><p>下一个问题是：我该合适准备一个新的帧？</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>这是以优化混成器为目的而采取的措施 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>',10),l=[s];function i(_,r,f,d,n,p){return c(),o("div",null,l)}const m=e(a,[["render",i]]);export{h as __pageData,m as default};
